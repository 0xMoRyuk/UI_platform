# Cloud Build CI/CD Configuration
# Automated deployment pipeline for UI Platform monorepo apps
#
# Features:
# - Separate builds per app with caching
# - Multi-environment support (staging/production)
# - Automated testing before deployment
# - Rollback capability with tagged images
#
# Trigger: git push to main branch
# Branch patterns: main (production), staging/* (staging)

substitutions:
  _APP_NAME: 'ai4su'  # Default to ai4su (most actively developed); override with --substitutions=_APP_NAME=web
  _REGION: 'europe-west1'
  _ENV: 'production'  # or 'staging'
  _MIN_INSTANCES: '0'  # scale-to-zero for cost optimization
  _MAX_INSTANCES: '10'
  _MEMORY: '512Mi'
  _CPU: '1'
  _TIMEOUT: '300s'

options:
  # Build optimizations
  machineType: 'E2_HIGHCPU_8'
  diskSizeGb: 100
  logging: CLOUD_LOGGING_ONLY

  substitution_option: 'ALLOW_LOOSE'

steps:
  # Step 0: Generate semantic version tag
  - name: 'gcr.io/cloud-builders/git'
    id: 'generate-version'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Generate version from git
        # Use SHORT_SHA if available (git push trigger), otherwise use git rev-parse (manual submit)
        if [ -n "${SHORT_SHA:-}" ]; then
          SHA="${SHORT_SHA}"
        else
          SHA=$(git rev-parse --short=7 HEAD 2>/dev/null || echo "manual")
        fi
        VERSION="v$(date +%Y%m%d)-$${SHA}"
        echo "$$VERSION" > /workspace/VERSION
        echo "Generated version: $$VERSION"

  # Step 1: Validate (type-check only - lint disabled due to pre-existing issues)
  - name: 'oven/bun:1'
    id: 'validate'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "üì¶ Installing dependencies..."
        bun install

        echo "üîç Running type-check..."
        bun run type-check

        # TODO: Re-enable lint after fixing pre-existing issues
        # echo "üßπ Running lint..."
        # bun run lint

        echo "‚úÖ Validation passed"
    waitFor: ['generate-version']

  # Step 2: Build Docker image
  - name: 'gcr.io/cloud-builders/docker'
    id: 'build'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        VERSION=$(cat /workspace/VERSION)
        # Compute service name from app name (no nested substitution)
        SERVICE_LOWER=$(echo "ui-platform-${_APP_NAME}" | tr '[:upper:]' '[:lower:]')

        # Detect app type (Next.js or Vite) from package.json
        if grep -q '"next"' apps/${_APP_NAME}/package.json 2>/dev/null; then
          DOCKERFILE="packages/infra/Dockerfile.next"
          echo "Detected Next.js app, using Dockerfile.next"
        else
          DOCKERFILE="packages/infra/Dockerfile.vite"
          echo "Detected Vite app, using Dockerfile.vite"
        fi

        echo "Building Docker image for ${_APP_NAME}..."
        docker build \
          -t gcr.io/$PROJECT_ID/$$SERVICE_LOWER:$$VERSION \
          -t gcr.io/$PROJECT_ID/$$SERVICE_LOWER:${_ENV} \
          -t gcr.io/$PROJECT_ID/$$SERVICE_LOWER:latest \
          --build-arg APP_NAME=${_APP_NAME} \
          -f $$DOCKERFILE \
          .
        echo "Pushing images..."
        docker push gcr.io/$PROJECT_ID/$$SERVICE_LOWER:$$VERSION
        docker push gcr.io/$PROJECT_ID/$$SERVICE_LOWER:${_ENV}
        docker push gcr.io/$PROJECT_ID/$$SERVICE_LOWER:latest
        # Store for deploy step
        echo "$$SERVICE_LOWER" > /workspace/SERVICE_LOWER
    waitFor: ['validate']

  # Step 3: Deploy to Cloud Run
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'deploy'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        VERSION=$(cat /workspace/VERSION)
        SERVICE_LOWER=$(cat /workspace/SERVICE_LOWER)

        echo "üöÄ Deploying ${_APP_NAME} to ${_ENV}..."
        echo "   Version: $$VERSION"
        echo "   Service: $$SERVICE_LOWER"
        echo "   Region: ${_REGION}"

        gcloud run deploy $$SERVICE_LOWER \
          --image=gcr.io/$PROJECT_ID/$$SERVICE_LOWER:$$VERSION \
          --platform=managed \
          --region=${_REGION} \
          --allow-unauthenticated \
          --min-instances=${_MIN_INSTANCES} \
          --max-instances=${_MAX_INSTANCES} \
          --memory=${_MEMORY} \
          --cpu=${_CPU} \
          --timeout=${_TIMEOUT} \
          --set-env-vars="NODE_ENV=production,APP_NAME=${_APP_NAME},DEPLOYED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          --tag=$$VERSION \
          --quiet

        # Route all traffic to latest revision
        echo "üìä Routing traffic to latest revision..."
        gcloud run services update-traffic $$SERVICE_LOWER \
          --region=${_REGION} \
          --to-latest \
          --quiet

        echo "‚úÖ Deployment complete!"

        # Get service URL
        SERVICE_URL=$(gcloud run services describe $$SERVICE_LOWER \
          --region=${_REGION} \
          --format='value(status.url)')

        echo ""
        echo "üåê Service URL: $$SERVICE_URL"
        echo "üì¶ Image: gcr.io/$PROJECT_ID/$$SERVICE_LOWER:$$VERSION"
        echo "üè∑Ô∏è  Version: $$VERSION"
    waitFor: ['build']

  # Step 4: Smoke test
  - name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    id: 'smoke-test'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        SERVICE_LOWER=$(cat /workspace/SERVICE_LOWER)
        SERVICE_URL=$(gcloud run services describe $$SERVICE_LOWER \
          --region=${_REGION} \
          --format='value(status.url)')

        echo "Running smoke test for ${_APP_NAME}..."

        # Test homepage
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" $$SERVICE_URL)
        if [ "$$HTTP_CODE" != "200" ]; then
          echo "‚ùå Homepage failed: $$HTTP_CODE"
          exit 1
        fi

        # Response time
        RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}\n' $$SERVICE_URL)
        echo "‚úÖ Homepage: 200 ($${RESPONSE_TIME}s)"
    waitFor: ['deploy']
    allowFailure: true

timeout: '1200s'  # 20 minutes total timeout

# Note: Images are pushed in the 'build' step directly.
# The 'images' field is omitted to avoid substitution validation issues.
